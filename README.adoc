= Teste para Backend: Spring-Boot 

O teste contém 2 módulos construídos com Spring Boot, se comunicando via troca de mensagens pelo RabbitMQ.

==== Aspectos gerais:

* API REST
* Testes de todos os `resources`, validações dos dados e respostas
* Banco de dados embarcado para não precisar instalar
* Contém pedaços de outros projetos na parte de `support`

==== Tecnologias:

* Jpa + Specifications
* Spring-Data
* Spring-Actuator
* Junit jupiter
* AssertJ
* Mockito
* Swagger
* Problem (org.zalando)
* Amqp + RabbitMQ
* SQL(h2)
* NOSQL(Mongo)


== Instalação e excução
Guia rápido para instalação dos componentes e dependências para a execução do teste.

==== Instalar o RabbitMQ via Docker

Executar o comando para instalar e executar o RabbitMQ:

[indent=0]
----
	$ ./docker run -d -p 5672:5672 -p 15672:15672 --name=rabbitmq rabbitmq:3.8.3-management
----

Apesar de o comando informar versão `3.8.3`, acredito que a `3.8.7` funcione, porém, não testei.

==== Instalar o Spring-Boot com Maven

Baixar o projeto do repositório ou clonar via git.
Em seguida, executar o maven nas pastas `debt` e `debtcollector` para baixar as dependências.


[indent=0]
----
	$ ./mvn clean install
----


Após baixar as dependências o projeto está pronto para execução. Entre nas pastas `debt` e `debtcollector` execute o comando:


[indent=0]
----
	$ ./mvn spring-boot:run
----


TIP: Caso queria passar um ip diferente de `localhost` para a conexão com o RabbitMQ, usar o comando:

Iniciar determinando um ip diferente para o RabbitMQ:

[indent=0]
----
	$ ./mvn spring-boot:run -Dspring-boot.run.arguments="--spring.rabbitmq.host={ip}"
----



== Interagindo com os serviços

Todas as rotas estão disponíveis via Swagger, em:

* Debts Service: http://localhost:8080/swagger-ui.html
* Debt-Collector Service: http://localhost:8081/swagger-ui.html


=== Serviço para dívidas (Debts Service)

O Debts Service é o serviço onde as dívidas são manipuladas. O serviço é construído com banco relacional, SQL, e está funcionando com um h2 em memória.

NOTE: O H2 foi escolhido apenas para a avaliação do teste ser mais fácil, sendo possível utilizar um PostgreSQL em produção

É possível incluir, consultar, pagar e remover dívidas. Quando uma dívidas é inserida, é lançanado uma notificação de cobrança.

IMPORTANT: As notificações são enviadas para o RabbitMQ, fila `debt.collector`

==== Dados via Web

Para desenvolver os serviços foram utilizados os seguintes para criar `debtors` e os `debts`.

TIP: Os dados podem ser inseridos e consultados via *https://www.postman.com/[Postman]*.


===== *1 - Criando os `debtors`*

Incluindo Fulano:

[source,http,indent=0]
----
	POST /api/debtors HTTP/1.1
	Host: localhost:8080
	Content-Type: application/json

	{
		"cpf": "82699703010",
		"name": "Fulano",
		"email": "fulano@web.net",
		"cellNumber": "21123451234"
	}
----

Incluindo Ciclano:

[source,http,indent=0]
----
	POST /api/debtors HTTP/1.1
	Host: localhost:8080
	Content-Type: application/json

	{
		"cpf": "64576239058",
		"name": "Ciclano",
		"cellNumber": "11123451234",
		"email": "ciclano@web.com"
	}
----

'''
===== *2 - Criando os `debts`*

CAUTION: Para incluir o `debt` é necessário ter um `debtor` cadastrado.

Incluindo dívida para Ciclano:

[source,http,indent=0]
----
	POST /api/debts HTTP/1.1
	Host: localhost:8080
	Content-Type: application/json

	{
		"dueDate": "2020-09-24",
		"value": "500.00",
		"cpfs": [
			"64576239058"
		]
	}
----

Incluindo dívida para Fulano e Ciclano:

[source,http,indent=0]
----
	POST /api/debts HTTP/1.1
	Host: localhost:8080
	Content-Type: application/json

	{
		"dueDate": "2020-09-22",
		"value": "605.00",
		"cpfs": [        
			"64576239058",
			"82699703010"
		]
	}
----

'''
===== *3 - Consultando todos `debtors` e `debts` com filtro e paginação*

Paginação: `page` e `size`

Obter todos os devedores:

[source,http,indent=0]
----
	GET /api/debtors HTTP/1.1
----

Filtros: `cpf`, `name`, `email` e `cellNumber`.

Obter todos as as dívidas:

[source,http,indent=0]
----
	GET /api/debtors HTTP/1.1
----

Filtros: `uuid`, `value`, `dueDate`, `status`(paid, unpaid) e `debtor`(id).

Filtros de range (inclusivo): `value` com `maxValue` e `dueDate` com `endDueDate`.

'''
===== *4 - Consultando `debtors` e `debts` por `id`*

Obter devedor:
[source,http,indent=0]
----
	GET /api/debtors/{debtorId} HTTP/1.1
----

Obter dívidas:
[source,http,indent=0]
----
	GET /api/debts/{debtId} HTTP/1.1
----

'''
===== *5 - Obter todos os `debts` de um `debtor` com paginação e filtros*

Obter todas dívidas de um devedor:
[source,http,indent=0]
----
	GET /api/debtors/{debtorId}/debts HTTP/1.1
----

ou

[source,http,indent=0]
----
	GET /api/debts?debtor={debtorId} HTTP/1.1
----

Paginação: `page` e `size`

Filtros: `uuid`, `value`, `dueDate` e `status`(paid, unpaid).

Filtros de range (inclusivo): `value` com `maxValue` e `dueDate` com `endDueDate`.

'''
===== *6 - Pagar um `debt`*

Pagar uma dívida:

[source,http,indent=0]
----
	PUT /api/debts/{debtId}/payoff HTTP/1.1
----

'''
===== *7 - Remover um `debtor` ou um `debt`*

Remover uma dívida:
[source,http,indent=0]
----
	DELETE /api/debts/{debtId} HTTP/1.1
----

Remover um devedor:

CAUTION: É possível remover apenas devedores sem dívidas

[source,http,indent=0]
----
	DELETE /api/debtors/{debtorId} HTTP/1.1
----

==== Dados via AMQP

Existem 3 tipos notificações são lançadas pelo Debts, para a fila `debt.collector` do RabbitMQ, quando algumas operações são realizadas via Web.

Essas notificações vão em pacotes chamados `Message`, com a operação e o dado do débito:

[source,json,indent=0]
----
{
    "operation": "POST",
    "data": {
		"uuid": "5cdecd30-f273-439c-9638-923318fb91c5",
        "dueDate": "2020-09-22",
        "value": "605.00",
        "debtors": [        
            { "name": "Fulano", "email": "fulano@web.net", "cellNumber": "21123451234" },
            { "name": "Ciclano", "email": "ciclano@web.com" , "cellNumber": "11123451234" }
        ]
    }
}
----

As operações contém os seguintes estados:

* `POST` - Novo débito
* `PUT`  - Débito atualizado
* `DELETE` - Débito removido ou pago

===== *1 - Ao criar um `debt`*

[source,json,indent=0]
----
{
    "operation": "POST",
    "data": {...}
}
----

'''
===== *2 - Ao editar um `debt`*

[source,json,indent=0]
----
{
    "operation": "PUT",
    "data": {...}
}
----

'''
===== *3 - Ao deletar ou pagar um `debt`*

[source,json,indent=0]
----
{
    "operation": "DELETE",
    "data": {...}
}
----

=== Serviço para cobranças (Debts-Collector Service)

O Debts-Collector é o serviço de cobrança que atua enviando mensagens aos respectivos devedores, com finalidade de lembrar as datas de pegamento.

Do ponto de vista técnico, o serviço Debts-Collector recebe notificações de cobrança lançadas pelo Debts, via RabbitMQ, e faz o armazenamento no MongoDB.

NOTE: O MongoDB está rodando embarcado apenas para a avaliação do teste ser mais fácil

NOTE: As notificações são recebidas da fila `debt.collector`

As mensagens são lançadas nas datas de 10 dias antes e 1 dia antes da data de vencimento e podem serem enviadas por: `sms`, `email`, `telefonemas` ou `whatsapp`.

==== Dados via WEB

NOTE: A inclusão de `debts` para o envio de mensagens de cobrança se dá via RabbitMQ

===== *1 - Consultando todos `debts` e `debtors` com filtro e paginação*

Obter todos as as dívidas:

[source,http,indent=0]
----
	GET /api/debts HTTP/1.1
----
Paginação: `page` e `size`

Filtros: `value`, `dueDate` e `debtor`(nome).

Filtros de range (inclusivo): `value` com `maxValue` e `dueDate` com `endDueDate`.

'''
===== *2 - Consultando `debtors` e `debts` por `id`*

Obter divida e devedores por `uuid`:

[source,http,indent=0]
----
	GET /api/debts/{uuid} HTTP/1.1
----


==== Dados via AMQP

A entrada de dados via eventos AMQP é o responsável por manupular os `debts`

===== *1 - Insere um `debt` quando recebe uma mensagem de criação de `debt` pelo Debts Service*

[source,json,indent=0]
----
{
    "operation": "POST",
    "data": {...}
}
----

'''
===== *2 - Atualiza o `debt` quando recebe uma mensagem de modificação de `debt` pelo Debts Service*

[source,json,indent=0]
----
{
    "operation": "PUT",
    "data": {...}
}
----

'''
===== *3 - Remove o `debt` quando recebe uma mensagem de deleção ou pagamento de `debt` pelo Debts Service*

[source,json,indent=0]
----
{
    "operation": "DELETE",
    "data": {...}
}
----

== Informações adicionais

Algumas informações adicionais.

=== Testes 

A ideia dos testes é manter o contrato mais consistente possível.

Para isso foram feitos testes de sistema usando todas as urls disponíveis.

Também foram feitos teste sobre das validações dos dados e os dados enviados e recebidos via AMQP.

=== CRON

A ideia é rodar o envio de mensagens com a seguinte regra cron:

[source,cron,indent=0]
----
	0 1 1 * * MON-FRI
----

O evento de envio deve rodar todos os dias úteis, 1:10 da manhã.